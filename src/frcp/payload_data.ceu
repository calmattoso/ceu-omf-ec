#ifndef _FRCP_PAYLOAD_DATA_CEU
#define _FRCP_PAYLOAD_DATA_CEU

#include "frcp_base.ceu"

/*
 * ```json
 * {
 *     "op" : "inform",
 *     "mid": ID,
 *     "src": RID,
 *     "ts" : TIMESTAMP,
 *    ["it" : TYPE,
 *     "cid": CID,
       "reason": REASON "]
 *    ....
 * }
 * ```
 *
 * The meaning of each fields is similar to the previous XML syntax above, i.e.
 * - op  :: `MTYPE`   = the type of message, either create, configure, request, inform, or release
 * - mid :: `ID`        = a globally unique ID for this message
 * - src :: `RID`       = a globally unique ID for the resource that published this message
 * - ts  :: `TIMESTAMP` = the Posix/Unix time in second when this message was generated by its publisher
 * - rp  :: `TOPIC`     = optional, if the publisher of this message would like any replying messages to be 
 *                        published to a specific TOPIC address  
 *
 * The `inform` message fields have the following meaning:
 * - it  :: `TYPE` = type of this inform message. All resources must support the following basic types: `CREATION.OK`, 
 *                   `CREATION.FAILED`, `STATUS`, `RELEASED`, `ERROR`, and `WARN`. In addition, any resource may define
 *                   its own particular types of inform message, following the convention `BASIC_TYPE.SPECIFIC_TYPE`. 
 *                   For example, if you have a custom resource which wants to return an inform message as a reply to a
 *                   configure message that contained a syntax error, then that custom resource may define and use the 
 *                   custom inform type `ERROR.SYNTAX`.
 *
 * - cid :: `CID`  = this is the Context ID for this message. This element or object must be present only if this 
 *                   inform message is a reply to another message, in which case CID must be the ID of the original 
 *                   message. This element is not present in a spontaneous inform message.
 *
 * - reason :: `REASON` = optional reason that explains in more detail why a failure occurred. 
 * 
 */

#define FRCP_ID_LEN 32

#define FRCP_RET_SUCCESS 0 // Return if operation was successful and has terminated.
#define FRCP_RET_ERROR   1 // Return if error occurred.
#define FRCP_RET_WIP     2 // Return when operation not fully completed.

#define FRCP_OP_CONFIGURE     "configure"
#define FRCP_OP_CREATE        "create"
#define FRCP_OP_INFORM        "inform"
#define FRCP_OP_REQUEST       "request"
#define FRCP_OP_RELEASE       "release"

#define FRCP_IT_CREATION_OK         "CREATION.OK"
#define FRCP_IT_CREATION_FAILED     "CREATION.FAILED"
#define FRCP_IT_STATUS              "STATUS"
#define FRCP_IT_RELEASE_OK          "RELEASE.OK"
#define FRCP_IT_RELEASE_FAILED      "RELEASE.FAILED"
#define FRCP_IT_ERROR               "ERROR"
#define FRCP_IT_WARN                "WARN"

data Payload with
    vector[] byte  op;
    vector[] byte  mid;     
    vector[] byte  src;
    vector[] byte  ts; 
    vector[] byte  rp    = [] .. "";  // optional
    vector[] byte  props = [] .. "";
    vector[] byte  guard = [] .. "";  // optional

    // Inform type attributes
    vector[] byte it     = [] .. "";
    vector[] byte cid    = [] .. ""; // if reply
    vector[] byte reason = [] .. ""; // optional
end

code/tight PayloadToJSON(var& Payload payload, vector&[] byte json_str) -> void
do
    var byte q = { '"' };

    json_str = json_str .. "{";

    json_str = json_str .. [q] .. "op"  .. [q] .. ": " .. [q] .. payload.op  .. [q] .. ",";  
    json_str = json_str .. [q] .. "mid" .. [q] .. ": " .. [q] .. payload.mid .. [q] .. ","; 
    json_str = json_str .. [q] .. "src" .. [q] .. ": " .. [q] .. payload.src .. [q] .. ",";
    json_str = json_str .. [q] .. "ts"  .. [q] .. ": " .. [q] .. payload.ts  .. [q] .. ",";

    if ($payload.rp > 0) then
        json_str = json_str .. [q] .. "rp" .. [q] .. " : " .. [q] .. payload.rp .. [q] .. ",";
    end


    if ($payload.it > 0) then
        json_str = json_str .. [q] .. "itype" .. [q] .. ": " .. [q] .. payload.it .. [q] .. ",";

        if ($payload.cid > 0) then
            json_str = json_str .. [q] .. "cid" .. [q] .. ": " .. [q] .. payload.cid .. [q] .. ",";
        end

        if ($payload.reason > 0) then
            json_str = json_str .. [q] .. "reason" .. [q] .. ": " .. [q] .. payload.reason .. [q] .. ",";
        end
    end   
 
    if ($payload.guard > 0) then
        json_str = json_str .. [q] .. "guard" .. [q] .. ": " .. payload.guard .. ",";
    end

    json_str = json_str .. [q] .. "props" .. [q] .. ": " .. payload.props .. "}";
end


code/tight JSONToPayload(vector&[] byte json_str, var& Payload payload) -> void
do
    [[
        frcp_json_tab = JSON:decode(@json_str)
    ]]
    
    payload.op     = [] .. [[ frcp_json_tab.op ]];
    payload.mid    = [] .. [[ frcp_json_tab.mid ]];
    payload.src    = [] .. [[ frcp_json_tab.src ]];
    payload.ts     = [] .. [[ frcp_json_tab.ts ]];
    payload.props  = [] .. [[ JSON:encode(frcp_json_tab.props) ]];
    payload.rp     = [] .. [[ frcp_json_tab.rp or "" ]];
    payload.it     = [] .. [[ frcp_json_tab.itype or "" ]];
    payload.cid    = [] .. [[ frcp_json_tab.cid or "" ]];
    payload.reason = [] .. [[ frcp_json_tab.reason or "" ]];
    payload.guard  = [] .. [[ JSON:encode(frcp_json_tab.guard) or "" ]];
end


#endif

